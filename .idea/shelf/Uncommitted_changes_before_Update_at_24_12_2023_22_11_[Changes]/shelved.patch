Index: copyfrom/boom them all/surface.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport os\r\nimport sys\r\nimport random\r\n\r\nsize = width, height = 800, 600\r\npygame.init()\r\npygame.display.set_caption(f'Balls, fps:{60}')\r\nscreen = pygame.display.set_mode(size)\r\nhorizontal_borders = pygame.sprite.Group()\r\nvertical_borders = pygame.sprite.Group()\r\n\r\n\r\ndef load_image(name, colorkey=None):\r\n    fullname = os.path.join('data', name)  # по директории дата\r\n    if not os.path.isfile(fullname):\r\n        print(f\"Файл с изображением '{fullname}' не найден\")\r\n        sys.exit()\r\n    image = pygame.image.load(fullname)\r\n    if colorkey is not None:\r\n        image = image.convert()\r\n        if colorkey == -1:\r\n            colorkey = image.get_at((0, 0))\r\n        image.set_colorkey(colorkey)\r\n    else:\r\n        image = image.convert_alpha()\r\n    return image\r\n\r\n\r\nclass Bomb(pygame.sprite.Sprite):\r\n    image = load_image(\"bomb.png\")\r\n    image_boom = load_image(\"boom.png\")\r\n\r\n    def __init__(self, *group):\r\n        # НЕОБХОДИМО вызвать конструктор родительского класса Sprite.\r\n        # Это очень важно !!!\r\n        super().__init__(*group)\r\n        self.image = Bomb.image\r\n        self.rect = self.image.get_rect()\r\n        self.rect.x = random.randrange(width - self.rect.width)\r\n        self.rect.y = random.randrange(height - self.rect.height)\r\n        self.mask = pygame.mask.from_surface(self.image)\r\n        while pygame.sprite.spritecollideany(self, all_sprites):\r\n            self.rect.x = random.randrange(width - self.rect.width)\r\n            self.rect.y = random.randrange(height - self.rect.height)\r\n\r\n    def update(self, *args):\r\n        if args and args[0].type == pygame.MOUSEBUTTONDOWN and \\\r\n                self.rect.collidepoint(args[0].pos):\r\n            self.image = self.image_boom\r\n\r\n\r\nif __name__ == '__main__':\r\n    play = False\r\n    running = True\r\n    fps = 60\r\n    clock = pygame.time.Clock()\r\n    image = pygame.Surface([100, 100])\r\n    image.fill(pygame.Color(\"red\"))\r\n    all_sprites = pygame.sprite.Group()\r\n\r\n    for _ in range(20):\r\n        bomb = Bomb()\r\n        all_sprites.add(bomb)\r\n\r\n    while running:\r\n        screen.fill('white')\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n            if event.type == pygame.MOUSEWHEEL:\r\n                fps = min(120, max(1, fps + int(event.precise_y)))\r\n                pygame.display.set_caption(f'Balls, fps:{fps}')\r\n        all_sprites.update(event)\r\n        all_sprites.draw(screen)\r\n        clock.tick(fps)\r\n        pygame.display.flip()\r\n        all_sprites.update()\r\n        horizontal_borders.draw(screen)\r\n        vertical_borders.draw(screen)\r\n\r\n    pygame.quit()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/copyfrom/boom them all/surface.py b/copyfrom/boom them all/surface.py
--- a/copyfrom/boom them all/surface.py	(revision 5d01e19b9747ae6bdd9d453c81ade5f460303e72)
+++ b/copyfrom/boom them all/surface.py	(date 1703421569595)
@@ -1,82 +1,198 @@
-import pygame
 import os
 import sys
-import random
+import pygame
+from useful_funcs import *
 
-size = width, height = 800, 600
 pygame.init()
-pygame.display.set_caption(f'Balls, fps:{60}')
-screen = pygame.display.set_mode(size)
-horizontal_borders = pygame.sprite.Group()
-vertical_borders = pygame.sprite.Group()
+
+FPS = 60
+WIDTH = 800
+HEIGHT = 600
+GRAVITY = 0.25
+MAX_JUMP_HEIGHT = 80
+RESISTANCE = 0.25
+screen = pygame.display.set_mode((WIDTH, HEIGHT))  # экран
+clock = pygame.time.Clock()
+
+all_sprites = pygame.sprite.Group()
+hero_group = pygame.sprite.Group()
+block_group = pygame.sprite.Group()
+block_names = ([f"{name} Big" for name in ["Autumn", "Fantasy", "Grass", "Jade", "Stone", "Wood"]] +
+              [f"{name} Big" for name in ["Autumn", "Fantasy", "Grass", "Jade", "Stone", "Wood"]])
+block_images = {key: load_image(rf"Terrain\Square Blocks\{key}.png") for key in block_names}
+
+
+class Block(pygame.sprite.Sprite):
+    def __init__(self, block_type, pos_x, pos_y):
+        super().__init__(block_group, all_sprites)
+        self.image = block_images[block_type]  # строка с названием
+        self.rect = self.image.get_rect().move(
+            pos_x, pos_y)  # получаем левый топ коорд холста и получаем передвинутый
+
+
+class Hero(pygame.sprite.Sprite):
+    def __init__(self, character, x, y):
+        super().__init__(hero_group, all_sprites)
+
+        path = rf"Main Characters\{character}\\"
+
+        self.frames_forward = {"Run": self.cut_sheet(load_image(path + "Run.png"), 12, 1),
+                               "Fall": self.cut_sheet(load_image(path + "Fall.png"), 1, 1),
+                               "Hit": self.cut_sheet(load_image(path + "Hit.png"), 7, 1),
+                               "Idle": self.cut_sheet(load_image(path + "Idle.png"), 11, 1),
+                               "Jump": self.cut_sheet(load_image(path + "Jump.png"), 1, 1),
+                               "Double Jump": self.cut_sheet(load_image(path + "Double Jump.png"), 6, 1)}
+        self.frames_backwards = {key: [pygame.transform.flip(self.frames_forward[key][i], True, False)
+                                       for i in range(len(self.frames_forward[key]))]
+                                 for key in self.frames_forward.keys()}
+
+        self.action = "Idle"
+
+        self.direction = 'right'
+        self.dx = 0
 
+        self.dy = 0
+        self.jump_number = 0
+        self.jump_increase = 0
+        self.cur_jump_height = 0
+        self.on_ground = False
 
-def load_image(name, colorkey=None):
-    fullname = os.path.join('data', name)  # по директории дата
-    if not os.path.isfile(fullname):
-        print(f"Файл с изображением '{fullname}' не найден")
-        sys.exit()
-    image = pygame.image.load(fullname)
-    if colorkey is not None:
-        image = image.convert()
-        if colorkey == -1:
-            colorkey = image.get_at((0, 0))
-        image.set_colorkey(colorkey)
-    else:
-        image = image.convert_alpha()
-    return image
-
-
-class Bomb(pygame.sprite.Sprite):
-    image = load_image("bomb.png")
-    image_boom = load_image("boom.png")
-
-    def __init__(self, *group):
-        # НЕОБХОДИМО вызвать конструктор родительского класса Sprite.
-        # Это очень важно !!!
-        super().__init__(*group)
-        self.image = Bomb.image
-        self.rect = self.image.get_rect()
-        self.rect.x = random.randrange(width - self.rect.width)
-        self.rect.y = random.randrange(height - self.rect.height)
-        self.mask = pygame.mask.from_surface(self.image)
-        while pygame.sprite.spritecollideany(self, all_sprites):
-            self.rect.x = random.randrange(width - self.rect.width)
-            self.rect.y = random.randrange(height - self.rect.height)
+        self.cur_frame = 0
+        self.image = self.frames_forward["Run"][self.cur_frame]
+        self.rect = self.rect.move(x, y)
+
+    def cut_sheet(self, sheet, columns, rows):
+        self.rect = pygame.Rect(0, 0, sheet.get_width() // columns, sheet.get_height() // rows)
+        cycle = []
+        for j in range(rows):
+            for i in range(columns):
+                frame_location = (self.rect.w * i, self.rect.h * j)
+                frame = sheet.subsurface(pygame.Rect(frame_location, self.rect.size))
+                frame.set_colorkey(frame.get_at((0, 0)))
+                cycle.append(frame)
+        return cycle
+
+    def set_image(self, direction, action):
+        if self.direction == 'right':
+            self.image = self.frames_forward[action][self.cur_frame]
+        else:
+            self.image = self.frames_backwards[action][self.cur_frame]
 
     def update(self, *args):
-        if args and args[0].type == pygame.MOUSEBUTTONDOWN and \
-                self.rect.collidepoint(args[0].pos):
-            self.image = self.image_boom
+        scancode: pygame.key.ScancodeWrapper = args[0]
+
+        has_resistance = 1
+        has_gravity = 1
+
+        if scancode[pygame.K_DOWN]:
+            self.dy += 0.1
+
+        if scancode[pygame.K_UP]:
+            self.jump_number = max(1, self.jump_number)
+            if self.cur_jump_height != MAX_JUMP_HEIGHT and not (not self.jump_increase and self.cur_jump_height > 0):
+                self.jump_increase = True
+                self.dy = -5
+                self.cur_jump_height = min(float(MAX_JUMP_HEIGHT), self.cur_jump_height - self.dy)
+                has_gravity = False
+            elif not self.jump_increase:
+                if self.jump_number == 1:
+                    self.jump_number += 1
+                    self.cur_jump_height = 0
+        else:
+            self.jump_increase = False
+        if scancode[pygame.K_RIGHT]:
+            self.direction = 'right'
+            if self.on_ground:
+                self.dx = min(5.0, self.dx + 0.1)
+            else:
+                self.dx = min(5.0, max(1.0, self.dx + 0.1))
+            if self.dx >= 0:
+                has_resistance = 0
+
+        if scancode[pygame.K_LEFT]:
+            self.direction = 'left'
+            if self.on_ground:
+                self.dx = max(-5.0, self.dx - 0.1)
+            else:
+                self.dx = max(-5.0, min(-1.0, self.dx - 0.1))
+            if self.dx <= 0:
+                has_resistance = 0
+
+        if has_resistance and self.dy == 0:
+            if self.dx < 0:
+                self.dx = min(0.0, self.dx + RESISTANCE)
+            else:
+                self.dx = max(0.0, self.dx - RESISTANCE)
+
+        if has_gravity:
+            self.dy = min(5.0, self.dy + GRAVITY)
 
+        self.rect = self.rect.move(self.dx, 0)
+        for block in block_group:
+            if self.rect.colliderect(block.rect):
+                if self.dx > 0:
+                    self.rect.x = block.rect.left - 1 - self.rect.width
+                else:
+                    self.rect.x = block.rect.right + 1
+                self.dx = 0
+        self.rect = self.rect.move(0, self.dy)
+        for block in block_group:
+            if self.rect.colliderect(block.rect):
+                if self.dy > 0:
+                    self.rect.y = block.rect.top - self.rect.height
+                    self.on_ground = True
+                else:
+                    self.rect.y = block.rect.bottom
+                self.dy = 0
+        self.on_ground = False
+        underground_rect = self.rect.move(0, 1)
+        for block in block_group:
+            if underground_rect.colliderect(block.rect):
+                self.on_ground = True
+                break
+        if self.on_ground:
+            self.dy = min(self.dy, 0)
+            self.cur_jump_height = 0
+            self.jump_number = 0
 
-if __name__ == '__main__':
-    play = False
-    running = True
-    fps = 60
-    clock = pygame.time.Clock()
-    image = pygame.Surface([100, 100])
-    image.fill(pygame.Color("red"))
-    all_sprites = pygame.sprite.Group()
+        if self.dy < 0:
+            self.on_ground = False
+            if self.jump_number == 1:
+                self.action = "Jump"
+            else:
+                self.action = "Double Jump"
+        elif self.dy > 0:
+            self.on_ground = False
+            self.action = "Fall"
+        elif self.dx != 0:
+            self.action = "Run"
+        else:
+            self.action = "Idle"
+
+        self.cur_frame = (self.cur_frame + 1) % len(self.frames_forward[self.action])
+        self.set_image(self.direction, self.action)
+
+
+dragon = Hero("Mask Dude", 50, 50)
+block = Block("Autumn Big", 600, 500)
+
+running = True
+start = True
+
 
-    for _ in range(20):
-        bomb = Bomb()
-        all_sprites.add(bomb)
+def terminate():
+    pygame.quit()
+    sys.exit()
+
 
-    while running:
-        screen.fill('white')
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                running = False
-            if event.type == pygame.MOUSEWHEEL:
-                fps = min(120, max(1, fps + int(event.precise_y)))
-                pygame.display.set_caption(f'Balls, fps:{fps}')
-        all_sprites.update(event)
-        all_sprites.draw(screen)
-        clock.tick(fps)
-        pygame.display.flip()
-        all_sprites.update()
-        horizontal_borders.draw(screen)
-        vertical_borders.draw(screen)
+while running:
+    for event in pygame.event.get():
+        if event.type == pygame.QUIT:
+            running = False
+    screen.fill(pygame.Color("orange"))
+    hero_group.update(pygame.key.get_pressed())
+    all_sprites.draw(screen)
+    pygame.display.flip()
+    clock.tick(FPS)
 
-    pygame.quit()
\ No newline at end of file
+pygame.quit()
Index: copyfrom/camera.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport os\r\nimport sys\r\n\r\nSIZE = WIDTH, HEIGHT = 400, 400\r\nFPS = 60\r\nclock = pygame.time.Clock()\r\npygame.init()\r\npygame.display.set_caption(f'Balls, fps:{60}')\r\nscreen = pygame.display.set_mode(SIZE)\r\ntiles_group = pygame.sprite.Group()\r\nall_sprites = pygame.sprite.Group()\r\nplayer_group = pygame.sprite.Group()\r\nplayer = None\r\n\r\n\r\ndef load_image(name, colorkey=None):\r\n    fullname = os.path.join('data', name)  # по директории дата\r\n    if not os.path.isfile(fullname):\r\n        print(f\"Файл с изображением '{fullname}' не найден\")\r\n        terminate()\r\n    image = pygame.image.load(fullname)\r\n    if colorkey is not None:\r\n        image = image.convert()\r\n        if colorkey == -1:\r\n            colorkey = image.get_at((0, 0))\r\n        image.set_colorkey(colorkey)\r\n    else:\r\n        image = image.convert_alpha()\r\n    return image\r\n\r\n\r\ndef terminate():\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\n\r\ndef start_screen():\r\n    intro_text = [\"ЗАСТАВКА\", \"\",\r\n                  \"Правила игры\",\r\n                  \"Если в правилах несколько строк,\",\r\n                  \"приходится выводить их построчно\"]\r\n\r\n    fon = pygame.transform.scale(load_image('fon.jpg'), (WIDTH, HEIGHT))  # фон с размерами окна\r\n    screen.blit(fon, (0, 0))\r\n    font = pygame.font.Font(None, 30)\r\n    text_coord = 50\r\n    for line in intro_text:\r\n        string_rendered = font.render(line, 1, pygame.Color('black'))  # текст, ..., цвет текста\r\n        intro_rect = string_rendered.get_rect()  # прямоугольник для строки\r\n        text_coord += 10\r\n        intro_rect.y = text_coord\r\n        intro_rect.x = 10\r\n        text_coord += intro_rect.height\r\n        screen.blit(string_rendered, intro_rect)\r\n\r\n    while True:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                terminate()\r\n            elif event.type == pygame.KEYDOWN or \\\r\n                    event.type == pygame.MOUSEBUTTONDOWN:\r\n                return  # начинаем игру\r\n        pygame.display.flip()\r\n        clock.tick(FPS)\r\n\r\n\r\ndef load_level(filename):\r\n    filename = \"data/\" + filename\r\n    if not os.path.exists(filename) or filename[len(filename) - 3:] != \"txt\":\r\n        print(f\"Файл '{filename}' не найден\")\r\n        terminate()\r\n    # читаем уровень, убирая символы перевода строки\r\n    with open(filename, 'r') as mapFile:\r\n        level_map = [line.strip() for line in mapFile]\r\n\r\n    # и подсчитываем максимальную длину\r\n    max_width = max(map(len, level_map))\r\n\r\n    # дополняем каждую строку пустыми клетками ('.')\r\n    return list(map(lambda x: x.ljust(max_width, '.'), level_map))\r\n\r\n\r\ndef generate_level(level):\r\n    new_player, x, y = None, None, None\r\n    for y in range(len(level)):\r\n        for x in range(len(level[y])):\r\n            if level[y][x] == '.':\r\n                Tile('empty', x, y)\r\n            elif level[y][x] == '#':\r\n                Tile('wall', x, y)\r\n            elif level[y][x] == '@':\r\n                Tile('empty', x, y)\r\n                new_player = Player(x, y)\r\n    # вернем игрока, а также размер поля в клетках\r\n    return new_player, x, y\r\n\r\n\r\ntile_images = {\r\n    'wall': load_image('box.png'),  # сразу пригрузить холст чтобы не загружать потом\r\n    'empty': load_image('grass.png')\r\n}\r\n\r\nplayer_image = load_image('mario.png')\r\n\r\ntile_width = tile_height = 50\r\n\r\n\r\nclass Tile(pygame.sprite.Sprite):\r\n    def __init__(self, tile_type, pos_x, pos_y):\r\n        super().__init__(tiles_group, all_sprites)\r\n        self.image = tile_images[tile_type]  # строка с названием\r\n        self.rect = self.image.get_rect().move(\r\n            tile_width * pos_x, tile_height * pos_y)  # получаем левый топ коорд холста и получаем передвинутый\r\n\r\n\r\nclass Player(pygame.sprite.Sprite):\r\n    def __init__(self, pos_x, pos_y):\r\n        super().__init__(player_group, all_sprites)\r\n        self.pos_x = pos_x\r\n        self.pos_y = pos_y\r\n        self.image = player_image\r\n        self.rect = self.image.get_rect().move(\r\n            tile_width * pos_x + 15, tile_height * pos_y + 5)\r\n\r\n    def update(self, key, *args):\r\n        if key == pygame.K_DOWN:\r\n            if self.pos_y + 1 < len(level) and level[self.pos_y + 1][self.pos_x] != '#':\r\n                self.pos_y += 1\r\n                self.rect = self.rect.move(0, tile_width)\r\n        if key == pygame.K_UP:\r\n            if self.pos_y - 1 >= 0 and level[self.pos_y - 1][self.pos_x] != '#':\r\n                self.pos_y -= 1\r\n                self.rect = self.rect.move(0, -tile_width)\r\n        if key == pygame.K_LEFT:\r\n            if self.pos_x - 1 >= 0 and level[self.pos_y][self.pos_x - 1] != '#':\r\n                self.pos_x -= 1\r\n                self.rect = self.rect.move(-tile_width, 0)\r\n        if key == pygame.K_RIGHT:\r\n            if self.pos_x + 1 < max(map(len, level)) and level[self.pos_y][self.pos_x + 1] != '#':\r\n                self.pos_x += 1\r\n                self.rect = self.rect.move(tile_width, 0)\r\n\r\n\r\nclass Camera:\r\n    # зададим начальный сдвиг камеры\r\n    def __init__(self):\r\n        self.dx = 0\r\n        self.dy = 0\r\n\r\n    # сдвинуть объект obj на смещение камеры\r\n    def apply(self, obj):\r\n        obj.rect.x += self.dx\r\n        obj.rect.y += self.dy\r\n\r\n    # позиционировать камеру на объекте target\r\n    def update(self, target):\r\n        self.dx = -(target.rect.x + target.rect.w // 2 - WIDTH // 2)\r\n        self.dy = -(target.rect.y + target.rect.h // 2 - HEIGHT // 2)\r\n\r\n\r\nif __name__ == '__main__':\r\n    level = load_level('map.txt')\r\n    start_screen()\r\n    camera = Camera()\r\n    player, level_x, level_y = generate_level(level)\r\n    camera.update(player)\r\n    for sprite in all_sprites:\r\n        camera.apply(sprite)\r\n    while True:\r\n        screen.fill('white')\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                terminate()\r\n            if event.type == pygame.MOUSEWHEEL:\r\n                FPS = min(120, max(1, FPS + int(event.precise_y)))\r\n                pygame.display.set_caption(f'Balls, fps:{FPS}')\r\n            if event.type == pygame.KEYDOWN:\r\n                all_sprites.update(event.key)\r\n                camera.update(player)\r\n                for sprite in all_sprites:\r\n                    camera.apply(sprite)\r\n        all_sprites.draw(screen)\r\n        player_group.draw(screen)\r\n        clock.tick(FPS)\r\n        pygame.display.flip()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/copyfrom/camera.py b/copyfrom/camera.py
--- a/copyfrom/camera.py	(revision 5d01e19b9747ae6bdd9d453c81ade5f460303e72)
+++ b/copyfrom/camera.py	(date 1703421569601)
@@ -155,6 +155,7 @@
 
     # позиционировать камеру на объекте target
     def update(self, target):
+        print(self.dx, self.dy)
         self.dx = -(target.rect.x + target.rect.w // 2 - WIDTH // 2)
         self.dy = -(target.rect.y + target.rect.h // 2 - HEIGHT // 2)
 
Index: new.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import  sys\r\nfrom useful_funcs import *\r\n\r\npygame.init()\r\n\r\nFPS = 60\r\nWIDTH = 800\r\nHEIGHT = 600\r\nGRAVITY = 0.25\r\nMAX_JUMP_HEIGHT = 80\r\nRESISTANCE = 0.25\r\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))  # экран\r\nclock = pygame.time.Clock()\r\n\r\nall_sprites = pygame.sprite.Group()\r\nhero_group = pygame.sprite.Group()\r\ntile_group = pygame.sprite.Group()\r\nbackground = pygame.sprite.Group()\r\ntiles = []\r\n\r\n\r\nclass Tile(pygame.sprite.Sprite):\r\n    def __init__(self, tile, x, y):\r\n        super().__init__(tile_group, background)\r\n        path = rf\"Background\\{tile}.png\"\r\n        self.x = x\r\n        self.y = y\r\n        self.image = load_image(path)\r\n        self.rect = pygame.Rect(0, 0, 50, 50)\r\n        self.rect = self.rect.move(x, y)\r\n        self.image = pygame.transform.scale(self.image, (50, 50))\r\n\r\n    def move(self, dx, dy):\r\n        if self.rect.x >= WIDTH or self.rect.y >= HEIGHT:\r\n            self.rect.x = self.rect.x - WIDTH - 50\r\n        else:\r\n            self.rect.x += 1\r\n\r\n\r\nclass Hero(pygame.sprite.Sprite):\r\n    def __init__(self, character, x, y):\r\n        super().__init__(hero_group, all_sprites)\r\n\r\n        path = rf\"Main Characters\\{character}\\\\\"\r\n\r\n        self.frames_forward = {\"Run\": self.cut_sheet(load_image(path + \"Run.png\"), 12, 1),\r\n                               \"Fall\": self.cut_sheet(load_image(path + \"Fall.png\"), 1, 1),\r\n                               \"Hit\": self.cut_sheet(load_image(path + \"Hit.png\"), 7, 1),\r\n                               \"Idle\": self.cut_sheet(load_image(path + \"Idle.png\"), 11, 1),\r\n                               \"Jump\": self.cut_sheet(load_image(path + \"Jump.png\"), 1, 1),\r\n                               \"Double Jump\": self.cut_sheet(load_image(path + \"Double Jump.png\"), 6, 1)}\r\n        self.frames_backwards = {key: [pygame.transform.flip(self.frames_forward[key][i], True, False)\r\n                                       for i in range(len(self.frames_forward[key]))]\r\n                                 for key in self.frames_forward.keys()}\r\n\r\n        self.action = \"Idle\"\r\n\r\n        self.direction = 'right'\r\n        self.dx = 0\r\n\r\n        self.dy = 0\r\n        self.jump_number = 0\r\n        self.jump_increase = 0\r\n        self.cur_jump_height = 0\r\n\r\n        self.cur_frame = 0\r\n        self.image = self.frames_forward[\"Run\"][self.cur_frame]\r\n        self.rect = self.rect.move(x, y)\r\n\r\n    def cut_sheet(self, sheet, columns, rows):\r\n        self.rect = pygame.Rect(0, 0, sheet.get_width() // columns, sheet.get_height() // rows)\r\n        cycle = []\r\n        for j in range(rows):\r\n            for i in range(columns):\r\n                frame_location = (self.rect.w * i, self.rect.h * j)\r\n                frame = sheet.subsurface(pygame.Rect(frame_location, self.rect.size))\r\n                frame.set_colorkey(frame.get_at((0, 0)))\r\n                cycle.append(frame)\r\n        return cycle\r\n\r\n    def set_image(self, direction, action):\r\n        if self.direction == 'right':\r\n            self.image = self.frames_forward[action][self.cur_frame]\r\n        else:\r\n            self.image = self.frames_backwards[action][self.cur_frame]\r\n\r\n    def update(self, *args):\r\n        scancode: pygame.key.ScancodeWrapper = args[0]\r\n\r\n        has_resistance = 1\r\n        has_gravity = 1\r\n\r\n        if scancode[pygame.K_DOWN]:\r\n            self.dy += 0.1\r\n\r\n        if scancode[pygame.K_UP]:\r\n            self.jump_number = max(1, self.jump_number)\r\n            if self.cur_jump_height != MAX_JUMP_HEIGHT and not (not self.jump_increase and self.cur_jump_height > 0):\r\n                self.jump_increase = True\r\n                self.dy = -5\r\n                self.cur_jump_height = min(float(MAX_JUMP_HEIGHT), self.cur_jump_height - self.dy)\r\n                has_gravity = False\r\n            elif not self.jump_increase:\r\n                if self.jump_number == 1:\r\n                    self.jump_number += 1\r\n                    self.cur_jump_height = 0\r\n        else:\r\n            self.jump_increase = False\r\n        if scancode[pygame.K_RIGHT]:\r\n            self.direction = 'right'\r\n            if not self.jump_number:\r\n                self.dx = min(5.0, self.dx + 0.1)\r\n            else:\r\n                self.dx = min(5.0, max(1.0, self.dx + 0.1))\r\n            if self.dx >= 0:\r\n                has_resistance = 0\r\n\r\n        if scancode[pygame.K_LEFT]:\r\n            self.direction = 'left'\r\n            if not self.jump_number:\r\n                self.dx = max(-5.0, self.dx - 0.1)\r\n            else:\r\n                self.dx = max(-5.0, min(-1.0, self.dx - 0.1))\r\n            if self.dx <= 0:\r\n                has_resistance = 0\r\n\r\n        if has_resistance and self.dy == 0:\r\n            if self.dx < 0:\r\n                self.dx = min(0.0, self.dx + RESISTANCE)\r\n            else:\r\n                self.dx = max(0.0, self.dx - RESISTANCE)\r\n\r\n        if has_gravity:\r\n            self.dy = min(5.0, self.dy + GRAVITY)\r\n\r\n        if self.rect.top == HEIGHT - self.rect.height:  # заменить на коллизию снизу\r\n            self.dy = min(self.dy, 0)\r\n            self.cur_jump_height = 0\r\n            self.jump_number = 0\r\n\r\n        if self.dy < 0:\r\n            if self.jump_number == 1:\r\n                self.action = \"Jump\"\r\n            else:\r\n                self.action = \"Double Jump\"\r\n        elif self.dy > 0:\r\n            self.action = \"Fall\"\r\n        elif self.dx != 0:\r\n            self.action = \"Run\"\r\n        else:\r\n            self.action = \"Idle\"\r\n\r\n        self.cur_frame = (self.cur_frame + 1) % len(self.frames_forward[self.action])\r\n        self.set_image(self.direction, self.action)\r\n        self.rect = self.rect.move(self.dx, self.dy)\r\n        self.rect.top = min(HEIGHT - self.rect.height, self.rect.top)\r\n\r\n\r\ndragon = Hero(\"Mask Dude\", 50, 50)\r\n\r\n\r\nrunning = False\r\nstart = True\r\n\r\n\r\ndef animate_background(pixels):\r\n    for pixel in pixels:\r\n        pixel.move(1, 1)\r\n\r\n\r\ndef terminate():\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\n\r\ndef start_screen():\r\n    global running, start\r\n\r\n    buttons = pygame.sprite.Group()\r\n    font = pygame.font.Font(None, 30)\r\n\r\n    play = pygame.sprite.Sprite()\r\n    settings = pygame.sprite.Sprite()\r\n    quitButton = pygame.sprite.Sprite()\r\n\r\n    play.image = load_image(rf\"menu\\buttons\\play.png\")\r\n    play.image = pygame.transform.scale(play.image, (75, 75))\r\n    rectPlay = pygame.Rect(WIDTH//2 - 200, HEIGHT // 2 - 150, 100, 100)\r\n    play.rect = rectPlay\r\n    buttons.add(play)\r\n\r\n    settings.image = load_image(rf\"menu\\buttons\\settings.png\")\r\n    settings.image = pygame.transform.scale(settings.image, (75, 75))\r\n    rectSetting = pygame.Rect(WIDTH // 2 - 200, HEIGHT // 2 - 50, 100, 100)\r\n    settings.rect = rectSetting\r\n    buttons.add(settings)\r\n\r\n    quitButton.image = load_image(rf\"menu\\buttons\\close.png\")\r\n    quitButton.image = pygame.transform.scale(quitButton.image, (75, 75))\r\n\r\n    rectQuit = pygame.Rect(WIDTH // 2 - 200, HEIGHT // 2 + 50, 100, 100)\r\n    quitButton.rect = rectQuit\r\n    buttons.add(quitButton)\r\n\r\n    colorsForBack = [\"Blue\", \"Pink\", \"Purple\"]\r\n    currentColor = 0\r\n\r\n    for i in range(0, 1600, 50):\r\n        for j in range(0, 1600, 50):\r\n            currentColor += 1\r\n            if currentColor > 2:\r\n                currentColor = 0\r\n            tile = Tile(colorsForBack[currentColor], i, j)\r\n            tiles.append(tile)\r\n\r\n    while start:\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.MOUSEBUTTONDOWN:\r\n                if rectPlay.collidepoint(event.pos):\r\n                    print(\"go\")\r\n                    running = True\r\n                    return\r\n                elif rectQuit.collidepoint(event.pos):\r\n                    terminate()\r\n            elif event.type == pygame.QUIT:\r\n                terminate()\r\n        background.draw(screen)\r\n        animate_background(tiles)\r\n        buttons.draw(screen)\r\n\r\n        string_rendered = font.render(\"play\", 1, pygame.Color('black'))\r\n        intro_rect = string_rendered.get_rect()\r\n        intro_rect.top = HEIGHT // 2 - 125\r\n        intro_rect.x = WIDTH // 2 - 100\r\n        screen.blit(string_rendered, intro_rect)\r\n\r\n        string_rendered = font.render(\"settings\", 1, pygame.Color('black'))\r\n        intro_rect = string_rendered.get_rect()\r\n        intro_rect.top = HEIGHT // 2 - 25\r\n        intro_rect.x = WIDTH // 2 - 100\r\n        screen.blit(string_rendered, intro_rect)\r\n\r\n        string_rendered = font.render(\"exit\", 1, pygame.Color('black'))\r\n        intro_rect = string_rendered.get_rect()\r\n        intro_rect.top = HEIGHT // 2 + 75\r\n        intro_rect.x = WIDTH // 2 - 100\r\n        screen.blit(string_rendered, intro_rect)\r\n\r\n        pygame.display.flip()\r\n        clock.tick(FPS)\r\n\r\n\r\nif start:\r\n    start_screen()\r\n\r\nwhile running:\r\n    for event in pygame.event.get():\r\n        if event.type == pygame.QUIT:\r\n            running = False\r\n    screen.fill(pygame.Color(\"orange\"))\r\n    hero_group.update(pygame.key.get_pressed())\r\n    all_sprites.draw(screen)\r\n    pygame.display.flip()\r\n    clock.tick(FPS)\r\n\r\npygame.quit()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/new.py b/new.py
--- a/new.py	(revision 5d01e19b9747ae6bdd9d453c81ade5f460303e72)
+++ b/new.py	(date 1703421596643)
@@ -1,5 +1,8 @@
-import  sys
+import os
+import sys
+import pygame
 from useful_funcs import *
+from settings import KEY_BINDS
 
 pygame.init()
 
@@ -14,27 +17,18 @@
 
 all_sprites = pygame.sprite.Group()
 hero_group = pygame.sprite.Group()
-tile_group = pygame.sprite.Group()
-background = pygame.sprite.Group()
-tiles = []
+block_group = pygame.sprite.Group()
+block_names = ([f"{name} Big" for name in ["Autumn", "Fantasy", "Grass", "Jade", "Stone", "Wood"]] +
+              [f"{name} Big" for name in ["Autumn", "Fantasy", "Grass", "Jade", "Stone", "Wood"]])
+block_images = {key: load_image(rf"Terrain\Square Blocks\{key}.png") for key in block_names}
 
 
-class Tile(pygame.sprite.Sprite):
-    def __init__(self, tile, x, y):
-        super().__init__(tile_group, background)
-        path = rf"Background\{tile}.png"
-        self.x = x
-        self.y = y
-        self.image = load_image(path)
-        self.rect = pygame.Rect(0, 0, 50, 50)
-        self.rect = self.rect.move(x, y)
-        self.image = pygame.transform.scale(self.image, (50, 50))
-
-    def move(self, dx, dy):
-        if self.rect.x >= WIDTH or self.rect.y >= HEIGHT:
-            self.rect.x = self.rect.x - WIDTH - 50
-        else:
-            self.rect.x += 1
+class Block(pygame.sprite.Sprite):
+    def __init__(self, block_type, pos_x, pos_y):
+        super().__init__(block_group, all_sprites)
+        self.image = block_images[block_type]  # строка с названием
+        self.rect = self.image.get_rect().move(
+            pos_x, pos_y)  # получаем левый топ коорд холста и получаем передвинутый
 
 
 class Hero(pygame.sprite.Sprite):
@@ -62,6 +56,7 @@
         self.jump_number = 0
         self.jump_increase = 0
         self.cur_jump_height = 0
+        self.on_ground = False
 
         self.cur_frame = 0
         self.image = self.frames_forward["Run"][self.cur_frame]
@@ -84,16 +79,44 @@
         else:
             self.image = self.frames_backwards[action][self.cur_frame]
 
+
+    def move_with_collision(self):
+        self.rect = self.rect.move(self.dx, 0)
+        for block in block_group:
+            if self.rect.colliderect(block.rect):
+                if self.dx > 0:
+                    self.rect.x = block.rect.left - self.rect.width
+                else:
+                    self.rect.x = block.rect.right
+                self.dx = 0
+        self.rect = self.rect.move(0, self.dy)
+        for block in block_group:
+            if self.rect.colliderect(block.rect):
+                if self.dy > 0:
+                    self.rect.y = block.rect.top - self.rect.height
+                    self.on_ground = True
+                else:
+                    self.rect.y = block.rect.bottom
+                    self.cur_jump_height = MAX_JUMP_HEIGHT
+                self.dy = 0
+        self.on_ground = False
+        underground_rect = self.rect.move(0, 1)
+        for block in block_group:
+            if underground_rect.colliderect(block.rect):
+                self.on_ground = True
+                break
+
+
     def update(self, *args):
         scancode: pygame.key.ScancodeWrapper = args[0]
 
         has_resistance = 1
         has_gravity = 1
 
-        if scancode[pygame.K_DOWN]:
+        if scancode[KEY_BINDS["KEY_DOWN"]]:
             self.dy += 0.1
 
-        if scancode[pygame.K_UP]:
+        if scancode[KEY_BINDS["KEY_UP"]]:
             self.jump_number = max(1, self.jump_number)
             if self.cur_jump_height != MAX_JUMP_HEIGHT and not (not self.jump_increase and self.cur_jump_height > 0):
                 self.jump_increase = True
@@ -106,19 +129,20 @@
                     self.cur_jump_height = 0
         else:
             self.jump_increase = False
-        if scancode[pygame.K_RIGHT]:
+
+        if scancode[KEY_BINDS["KEY_RIGHT"]]:
             self.direction = 'right'
-            if not self.jump_number:
-                self.dx = min(5.0, self.dx + 0.1)
+            if self.on_ground:
+                self.dx = min(5.0, self.dx + 0.15)
             else:
                 self.dx = min(5.0, max(1.0, self.dx + 0.1))
             if self.dx >= 0:
                 has_resistance = 0
 
-        if scancode[pygame.K_LEFT]:
+        if scancode[KEY_BINDS["KEY_LEFT"]]:
             self.direction = 'left'
-            if not self.jump_number:
-                self.dx = max(-5.0, self.dx - 0.1)
+            if self.on_ground:
+                self.dx = max(-5.0, self.dx - 0.15)
             else:
                 self.dx = max(-5.0, min(-1.0, self.dx - 0.1))
             if self.dx <= 0:
@@ -133,17 +157,21 @@
         if has_gravity:
             self.dy = min(5.0, self.dy + GRAVITY)
 
-        if self.rect.top == HEIGHT - self.rect.height:  # заменить на коллизию снизу
+        self.move_with_collision()
+
+        if self.on_ground:
             self.dy = min(self.dy, 0)
             self.cur_jump_height = 0
             self.jump_number = 0
 
         if self.dy < 0:
+            self.on_ground = False
             if self.jump_number == 1:
                 self.action = "Jump"
             else:
                 self.action = "Double Jump"
         elif self.dy > 0:
+            self.on_ground = False
             self.action = "Fall"
         elif self.dx != 0:
             self.action = "Run"
@@ -152,108 +180,46 @@
 
         self.cur_frame = (self.cur_frame + 1) % len(self.frames_forward[self.action])
         self.set_image(self.direction, self.action)
-        self.rect = self.rect.move(self.dx, self.dy)
-        self.rect.top = min(HEIGHT - self.rect.height, self.rect.top)
+
+
+class Camera:
+    # зададим начальный сдвиг камеры
+    def __init__(self):
+        self.dx = 0
+        self.dy = 0
+
+    # сдвинуть объект obj на смещение камеры
+    def apply(self, obj):
+        obj.rect.x += self.dx
+        obj.rect.y += self.dy
+
+    # позиционировать камеру на объекте target
+    def update(self, target):
+        self.dx = -(target.rect.x + target.rect.w // 2 - WIDTH // 6)
+        self.dy = -(target.rect.y + target.rect.h // 2 - HEIGHT // 1.2)
 
 
 dragon = Hero("Mask Dude", 50, 50)
+for i in range(20):
+    block = Block("Autumn Big", 0 + i * 48, 500)
 
-
-running = False
+from random import randint
+for i in range(20):
+    block = Block("Fantasy Big", randint(0, 740), randint(0, 540))
+running = True
 start = True
 
 
-def animate_background(pixels):
-    for pixel in pixels:
-        pixel.move(1, 1)
-
-
 def terminate():
     pygame.quit()
     sys.exit()
 
 
-def start_screen():
-    global running, start
-
-    buttons = pygame.sprite.Group()
-    font = pygame.font.Font(None, 30)
-
-    play = pygame.sprite.Sprite()
-    settings = pygame.sprite.Sprite()
-    quitButton = pygame.sprite.Sprite()
-
-    play.image = load_image(rf"menu\buttons\play.png")
-    play.image = pygame.transform.scale(play.image, (75, 75))
-    rectPlay = pygame.Rect(WIDTH//2 - 200, HEIGHT // 2 - 150, 100, 100)
-    play.rect = rectPlay
-    buttons.add(play)
-
-    settings.image = load_image(rf"menu\buttons\settings.png")
-    settings.image = pygame.transform.scale(settings.image, (75, 75))
-    rectSetting = pygame.Rect(WIDTH // 2 - 200, HEIGHT // 2 - 50, 100, 100)
-    settings.rect = rectSetting
-    buttons.add(settings)
-
-    quitButton.image = load_image(rf"menu\buttons\close.png")
-    quitButton.image = pygame.transform.scale(quitButton.image, (75, 75))
-
-    rectQuit = pygame.Rect(WIDTH // 2 - 200, HEIGHT // 2 + 50, 100, 100)
-    quitButton.rect = rectQuit
-    buttons.add(quitButton)
-
-    colorsForBack = ["Blue", "Pink", "Purple"]
-    currentColor = 0
-
-    for i in range(0, 1600, 50):
-        for j in range(0, 1600, 50):
-            currentColor += 1
-            if currentColor > 2:
-                currentColor = 0
-            tile = Tile(colorsForBack[currentColor], i, j)
-            tiles.append(tile)
-
-    while start:
-        for event in pygame.event.get():
-            if event.type == pygame.MOUSEBUTTONDOWN:
-                if rectPlay.collidepoint(event.pos):
-                    print("go")
-                    running = True
-                    return
-                elif rectQuit.collidepoint(event.pos):
-                    terminate()
-            elif event.type == pygame.QUIT:
-                terminate()
-        background.draw(screen)
-        animate_background(tiles)
-        buttons.draw(screen)
-
-        string_rendered = font.render("play", 1, pygame.Color('black'))
-        intro_rect = string_rendered.get_rect()
-        intro_rect.top = HEIGHT // 2 - 125
-        intro_rect.x = WIDTH // 2 - 100
-        screen.blit(string_rendered, intro_rect)
-
-        string_rendered = font.render("settings", 1, pygame.Color('black'))
-        intro_rect = string_rendered.get_rect()
-        intro_rect.top = HEIGHT // 2 - 25
-        intro_rect.x = WIDTH // 2 - 100
-        screen.blit(string_rendered, intro_rect)
-
-        string_rendered = font.render("exit", 1, pygame.Color('black'))
-        intro_rect = string_rendered.get_rect()
-        intro_rect.top = HEIGHT // 2 + 75
-        intro_rect.x = WIDTH // 2 - 100
-        screen.blit(string_rendered, intro_rect)
-
-        pygame.display.flip()
-        clock.tick(FPS)
-
-
-if start:
-    start_screen()
-
 while running:
+    camera = Camera()
+    camera.update(dragon)
+    for sprite in all_sprites:
+        camera.apply(sprite)
     for event in pygame.event.get():
         if event.type == pygame.QUIT:
             running = False
Index: settings.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/settings.py b/settings.py
new file mode 100644
--- /dev/null	(date 1703421574635)
+++ b/settings.py	(date 1703421574635)
@@ -0,0 +1,7 @@
+import pygame
+KEY_BINDS = {
+    "KEY_UP": pygame.K_UP,
+    "KEY_DOWN": pygame.K_DOWN,
+    "KEY_LEFT": pygame.K_LEFT,
+    "KEY_RIGHT": pygame.K_RIGHT,
+}
\ No newline at end of file
Index: copyfrom/data/map.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/copyfrom/data/map.txt b/copyfrom/data/map.txt
new file mode 100644
--- /dev/null	(date 1703421574642)
+++ b/copyfrom/data/map.txt	(date 1703421574642)
@@ -0,0 +1,11 @@
+...###
+..##.#.####
+.##..###..#
+##........#
+#...@..#..#
+###..###..#
+..#..#....#
+.##.##.#.##
+.#......##
+.#.....##
+.#######
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"db432080-e122-48bf-876e-ff341894dc7c\" name=\"Changes\" comment=\"trash\">\r\n      <change afterPath=\"$PROJECT_DIR$/menu.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/new.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/new.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 0\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2ZqdIk3IHhkBgMLOZnvZ4U7yMdG\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Python.a.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.dragon.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.new.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.particles.executor&quot;: &quot;Run&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;master&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/pythonprojects/platformer/data/Main Characters/Mask Dude&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.lookFeel&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\pythonprojects\\platformer\\data\\Main Characters\\Mask Dude\" />\r\n      <recent name=\"C:\\pythonprojects\\platformer\\copyfrom\" />\r\n      <recent name=\"C:\\pythonprojects\\platformer\" />\r\n      <recent name=\"C:\\pythonprojects\\platformer\\data\" />\r\n    </key>\r\n    <key name=\"MoveFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\pythonprojects\\platformer\\data\\Background\" />\r\n      <recent name=\"C:\\pythonprojects\\platformer\\data\" />\r\n      <recent name=\"C:\\pythonprojects\\platformer\" />\r\n      <recent name=\"C:\\pythonprojects\\platformer\\data\\Main Characters\\Virtual Guy\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-python-sdk-7a29c1521ef0-d3b881c8e49f-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-233.11799.298\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"db432080-e122-48bf-876e-ff341894dc7c\" name=\"Changes\" comment=\"\" />\r\n      <created>1703153465728</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1703153465728</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"new\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1703153490128</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1703153490128</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"trash\">\r\n      <created>1703335304733</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1703335304733</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"trash\">\r\n      <created>1703338554132</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1703338554132</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"trash\">\r\n      <created>1703340943674</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1703340943674</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"trash\">\r\n      <created>1703387375327</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1703387375327</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"6\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"new\" />\r\n    <MESSAGE value=\"trash\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"trash\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/useful_funcs.py</url>\r\n          <option name=\"timeStamp\" value=\"1\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 5d01e19b9747ae6bdd9d453c81ade5f460303e72)
+++ b/.idea/workspace.xml	(date 1703421830529)
@@ -5,8 +5,15 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="db432080-e122-48bf-876e-ff341894dc7c" name="Changes" comment="trash">
-      <change afterPath="$PROJECT_DIR$/menu.py" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/copyfrom/data/box.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/copyfrom/data/fon.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/copyfrom/data/grass.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/copyfrom/data/map.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/copyfrom/data/mario.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/settings.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/copyfrom/boom them all/surface.py" beforeDir="false" afterPath="$PROJECT_DIR$/copyfrom/boom them all/surface.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/copyfrom/camera.py" beforeDir="false" afterPath="$PROJECT_DIR$/copyfrom/camera.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/new.py" beforeDir="false" afterPath="$PROJECT_DIR$/new.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -108,14 +115,7 @@
       <option name="project" value="LOCAL" />
       <updated>1703340943674</updated>
     </task>
-    <task id="LOCAL-00005" summary="trash">
-      <created>1703387375327</created>
-      <option name="number" value="00005" />
-      <option name="presentableId" value="LOCAL-00005" />
-      <option name="project" value="LOCAL" />
-      <updated>1703387375327</updated>
-    </task>
-    <option name="localTasksCounter" value="6" />
+    <option name="localTasksCounter" value="5" />
     <servers />
   </component>
   <component name="VcsManagerConfiguration">
