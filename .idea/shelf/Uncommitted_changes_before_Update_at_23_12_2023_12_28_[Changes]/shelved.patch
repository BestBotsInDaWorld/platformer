Index: useful_funcs.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/useful_funcs.py b/useful_funcs.py
new file mode 100644
--- /dev/null	(date 1703161897659)
+++ b/useful_funcs.py	(date 1703161897659)
@@ -0,0 +1,18 @@
+import os
+import pygame
+
+
+def load_image(name, color_key=None):
+    fullname = os.path.join('data', name)
+    try:
+        image = pygame.image.load(fullname).convert()
+    except pygame.error as message:
+        print('Cannot load image:', name)
+        raise SystemExit(message)
+
+    if color_key is not None:
+        if color_key == -1:
+            color_key = image.get_at((0, 0))
+        image.set_colorkey(color_key)
+
+    return image
Index: copyfrom/boom them all/surface.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/copyfrom/boom them all/surface.py b/copyfrom/boom them all/surface.py
new file mode 100644
--- /dev/null	(date 1702363398000)
+++ b/copyfrom/boom them all/surface.py	(date 1702363398000)
@@ -0,0 +1,82 @@
+import pygame
+import os
+import sys
+import random
+
+size = width, height = 800, 600
+pygame.init()
+pygame.display.set_caption(f'Balls, fps:{60}')
+screen = pygame.display.set_mode(size)
+horizontal_borders = pygame.sprite.Group()
+vertical_borders = pygame.sprite.Group()
+
+
+def load_image(name, colorkey=None):
+    fullname = os.path.join('data', name)  # по директории дата
+    if not os.path.isfile(fullname):
+        print(f"Файл с изображением '{fullname}' не найден")
+        sys.exit()
+    image = pygame.image.load(fullname)
+    if colorkey is not None:
+        image = image.convert()
+        if colorkey == -1:
+            colorkey = image.get_at((0, 0))
+        image.set_colorkey(colorkey)
+    else:
+        image = image.convert_alpha()
+    return image
+
+
+class Bomb(pygame.sprite.Sprite):
+    image = load_image("bomb.png")
+    image_boom = load_image("boom.png")
+
+    def __init__(self, *group):
+        # НЕОБХОДИМО вызвать конструктор родительского класса Sprite.
+        # Это очень важно !!!
+        super().__init__(*group)
+        self.image = Bomb.image
+        self.rect = self.image.get_rect()
+        self.rect.x = random.randrange(width - self.rect.width)
+        self.rect.y = random.randrange(height - self.rect.height)
+        self.mask = pygame.mask.from_surface(self.image)
+        while pygame.sprite.spritecollideany(self, all_sprites):
+            self.rect.x = random.randrange(width - self.rect.width)
+            self.rect.y = random.randrange(height - self.rect.height)
+
+    def update(self, *args):
+        if args and args[0].type == pygame.MOUSEBUTTONDOWN and \
+                self.rect.collidepoint(args[0].pos):
+            self.image = self.image_boom
+
+
+if __name__ == '__main__':
+    play = False
+    running = True
+    fps = 60
+    clock = pygame.time.Clock()
+    image = pygame.Surface([100, 100])
+    image.fill(pygame.Color("red"))
+    all_sprites = pygame.sprite.Group()
+
+    for _ in range(20):
+        bomb = Bomb()
+        all_sprites.add(bomb)
+
+    while running:
+        screen.fill('white')
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                running = False
+            if event.type == pygame.MOUSEWHEEL:
+                fps = min(120, max(1, fps + int(event.precise_y)))
+                pygame.display.set_caption(f'Balls, fps:{fps}')
+        all_sprites.update(event)
+        all_sprites.draw(screen)
+        clock.tick(fps)
+        pygame.display.flip()
+        all_sprites.update()
+        horizontal_borders.draw(screen)
+        vertical_borders.draw(screen)
+
+    pygame.quit()
\ No newline at end of file
Index: copyfrom/camera.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/copyfrom/camera.py b/copyfrom/camera.py
new file mode 100644
--- /dev/null	(date 1703154341064)
+++ b/copyfrom/camera.py	(date 1703154341064)
@@ -0,0 +1,186 @@
+import pygame
+import os
+import sys
+
+SIZE = WIDTH, HEIGHT = 400, 400
+FPS = 60
+clock = pygame.time.Clock()
+pygame.init()
+pygame.display.set_caption(f'Balls, fps:{60}')
+screen = pygame.display.set_mode(SIZE)
+tiles_group = pygame.sprite.Group()
+all_sprites = pygame.sprite.Group()
+player_group = pygame.sprite.Group()
+player = None
+
+
+def load_image(name, colorkey=None):
+    fullname = os.path.join('data', name)  # по директории дата
+    if not os.path.isfile(fullname):
+        print(f"Файл с изображением '{fullname}' не найден")
+        terminate()
+    image = pygame.image.load(fullname)
+    if colorkey is not None:
+        image = image.convert()
+        if colorkey == -1:
+            colorkey = image.get_at((0, 0))
+        image.set_colorkey(colorkey)
+    else:
+        image = image.convert_alpha()
+    return image
+
+
+def terminate():
+    pygame.quit()
+    sys.exit()
+
+
+def start_screen():
+    intro_text = ["ЗАСТАВКА", "",
+                  "Правила игры",
+                  "Если в правилах несколько строк,",
+                  "приходится выводить их построчно"]
+
+    fon = pygame.transform.scale(load_image('fon.jpg'), (WIDTH, HEIGHT))  # фон с размерами окна
+    screen.blit(fon, (0, 0))
+    font = pygame.font.Font(None, 30)
+    text_coord = 50
+    for line in intro_text:
+        string_rendered = font.render(line, 1, pygame.Color('black'))  # текст, ..., цвет текста
+        intro_rect = string_rendered.get_rect()  # прямоугольник для строки
+        text_coord += 10
+        intro_rect.y = text_coord
+        intro_rect.x = 10
+        text_coord += intro_rect.height
+        screen.blit(string_rendered, intro_rect)
+
+    while True:
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                terminate()
+            elif event.type == pygame.KEYDOWN or \
+                    event.type == pygame.MOUSEBUTTONDOWN:
+                return  # начинаем игру
+        pygame.display.flip()
+        clock.tick(FPS)
+
+
+def load_level(filename):
+    filename = "data/" + filename
+    if not os.path.exists(filename) or filename[len(filename) - 3:] != "txt":
+        print(f"Файл '{filename}' не найден")
+        terminate()
+    # читаем уровень, убирая символы перевода строки
+    with open(filename, 'r') as mapFile:
+        level_map = [line.strip() for line in mapFile]
+
+    # и подсчитываем максимальную длину
+    max_width = max(map(len, level_map))
+
+    # дополняем каждую строку пустыми клетками ('.')
+    return list(map(lambda x: x.ljust(max_width, '.'), level_map))
+
+
+def generate_level(level):
+    new_player, x, y = None, None, None
+    for y in range(len(level)):
+        for x in range(len(level[y])):
+            if level[y][x] == '.':
+                Tile('empty', x, y)
+            elif level[y][x] == '#':
+                Tile('wall', x, y)
+            elif level[y][x] == '@':
+                Tile('empty', x, y)
+                new_player = Player(x, y)
+    # вернем игрока, а также размер поля в клетках
+    return new_player, x, y
+
+
+tile_images = {
+    'wall': load_image('box.png'),  # сразу пригрузить холст чтобы не загружать потом
+    'empty': load_image('grass.png')
+}
+
+player_image = load_image('mario.png')
+
+tile_width = tile_height = 50
+
+
+class Tile(pygame.sprite.Sprite):
+    def __init__(self, tile_type, pos_x, pos_y):
+        super().__init__(tiles_group, all_sprites)
+        self.image = tile_images[tile_type]  # строка с названием
+        self.rect = self.image.get_rect().move(
+            tile_width * pos_x, tile_height * pos_y)  # получаем левый топ коорд холста и получаем передвинутый
+
+
+class Player(pygame.sprite.Sprite):
+    def __init__(self, pos_x, pos_y):
+        super().__init__(player_group, all_sprites)
+        self.pos_x = pos_x
+        self.pos_y = pos_y
+        self.image = player_image
+        self.rect = self.image.get_rect().move(
+            tile_width * pos_x + 15, tile_height * pos_y + 5)
+
+    def update(self, key, *args):
+        if key == pygame.K_DOWN:
+            if self.pos_y + 1 < len(level) and level[self.pos_y + 1][self.pos_x] != '#':
+                self.pos_y += 1
+                self.rect = self.rect.move(0, tile_width)
+        if key == pygame.K_UP:
+            if self.pos_y - 1 >= 0 and level[self.pos_y - 1][self.pos_x] != '#':
+                self.pos_y -= 1
+                self.rect = self.rect.move(0, -tile_width)
+        if key == pygame.K_LEFT:
+            if self.pos_x - 1 >= 0 and level[self.pos_y][self.pos_x - 1] != '#':
+                self.pos_x -= 1
+                self.rect = self.rect.move(-tile_width, 0)
+        if key == pygame.K_RIGHT:
+            if self.pos_x + 1 < max(map(len, level)) and level[self.pos_y][self.pos_x + 1] != '#':
+                self.pos_x += 1
+                self.rect = self.rect.move(tile_width, 0)
+
+
+class Camera:
+    # зададим начальный сдвиг камеры
+    def __init__(self):
+        self.dx = 0
+        self.dy = 0
+
+    # сдвинуть объект obj на смещение камеры
+    def apply(self, obj):
+        obj.rect.x += self.dx
+        obj.rect.y += self.dy
+
+    # позиционировать камеру на объекте target
+    def update(self, target):
+        self.dx = -(target.rect.x + target.rect.w // 2 - WIDTH // 2)
+        self.dy = -(target.rect.y + target.rect.h // 2 - HEIGHT // 2)
+
+
+if __name__ == '__main__':
+    level = load_level('map.txt')
+    start_screen()
+    camera = Camera()
+    player, level_x, level_y = generate_level(level)
+    camera.update(player)
+    for sprite in all_sprites:
+        camera.apply(sprite)
+    while True:
+        screen.fill('white')
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                terminate()
+            if event.type == pygame.MOUSEWHEEL:
+                FPS = min(120, max(1, FPS + int(event.precise_y)))
+                pygame.display.set_caption(f'Balls, fps:{FPS}')
+            if event.type == pygame.KEYDOWN:
+                all_sprites.update(event.key)
+                camera.update(player)
+                for sprite in all_sprites:
+                    camera.apply(sprite)
+        all_sprites.draw(screen)
+        player_group.draw(screen)
+        clock.tick(FPS)
+        pygame.display.flip()
\ No newline at end of file
Index: copyfrom/desant/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/copyfrom/desant/main.py b/copyfrom/desant/main.py
new file mode 100644
--- /dev/null	(date 1702362626000)
+++ b/copyfrom/desant/main.py	(date 1702362626000)
@@ -0,0 +1,84 @@
+import pygame
+import os
+import sys
+import random
+
+size = width, height = 800, 600
+pygame.init()
+pygame.display.set_caption(f'Balls, fps:{60}')
+screen = pygame.display.set_mode(size)
+all_sprites = pygame.sprite.Group()
+
+
+def load_image(name, colorkey=None):
+    fullname = os.path.join('data', name)  # по директории дата
+    if not os.path.isfile(fullname):
+        print(f"Файл с изображением '{fullname}' не найден")
+        sys.exit()
+    image = pygame.image.load(fullname)
+    if colorkey is not None:
+        image = image.convert()
+        if colorkey == -1:
+            colorkey = image.get_at((0, 0))
+        image.set_colorkey(colorkey)
+    else:
+        image = image.convert_alpha()
+    return image
+
+
+class Mountain(pygame.sprite.Sprite):
+    image = load_image("mountains.png")
+
+    def __init__(self):
+        super().__init__(all_sprites)
+        self.image = Mountain.image
+        self.rect = self.image.get_rect()
+        # вычисляем маску для эффективного сравнения
+        self.mask = pygame.mask.from_surface(self.image)
+        # располагаем горы внизу
+        self.rect.bottom = height
+
+
+class Landing(pygame.sprite.Sprite):
+    image = load_image("pt.png")
+
+    def __init__(self, pos):
+        super().__init__(all_sprites)
+        self.image = Landing.image
+        self.rect = self.image.get_rect()
+        # вычисляем маску для эффективного сравнения
+        self.mask = pygame.mask.from_surface(self.image)
+        self.rect.x = pos[0]
+        self.rect.y = pos[1]
+
+    def update(self):
+        # если ещё в небе
+        if not pygame.sprite.collide_mask(self, mountain):  # mountain в игровом цикле
+            self.rect = self.rect.move(0, 1)
+
+
+if __name__ == '__main__':
+    play = False
+    running = True
+    fps = 60
+    clock = pygame.time.Clock()
+    image = pygame.Surface([100, 100])
+    image.fill(pygame.Color("black"))
+
+    while running:
+        mountain = Mountain()
+        screen.fill('white')
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                running = False
+            if event.type == pygame.MOUSEBUTTONDOWN:
+                Landing(event.pos)
+            if event.type == pygame.MOUSEWHEEL:
+                fps = min(120, max(1, fps + int(event.precise_y)))
+                pygame.display.set_caption(f'Balls, fps:{fps}')
+        all_sprites.draw(screen)
+        clock.tick(fps)
+        pygame.display.flip()
+        all_sprites.update()
+
+    pygame.quit()
Index: copyfrom/dragon.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/copyfrom/dragon.py b/copyfrom/dragon.py
new file mode 100644
--- /dev/null	(date 1702968319690)
+++ b/copyfrom/dragon.py	(date 1702968319690)
@@ -0,0 +1,69 @@
+import os
+import pygame
+
+pygame.init()
+
+FPS = 10
+WIDTH = 200
+HEIGHT = 200
+screen = pygame.display.set_mode((WIDTH, HEIGHT))
+clock = pygame.time.Clock()
+
+all_sprites = pygame.sprite.Group()
+
+
+def load_image(name, color_key=None):
+    fullname = os.path.join('data', name)
+    try:
+        image = pygame.image.load(fullname).convert()
+    except pygame.error as message:
+        print('Cannot load image:', name)
+        raise SystemExit(message)
+
+    if color_key is not None:
+        if color_key == -1:
+            color_key = image.get_at((0, 0))
+        image.set_colorkey(color_key)
+    else:
+        image = image.convert_alpha()
+    return image
+
+
+
+class AnimatedSprite(pygame.sprite.Sprite):
+    def __init__(self, sheet, columns, rows, x, y):
+        super().__init__(all_sprites)
+        self.frames = []
+        self.cut_sheet(sheet, columns, rows)
+        self.cur_frame = 0
+        self.image = self.frames[self.cur_frame]
+        self.rect = self.rect.move(x, y)
+
+    def cut_sheet(self, sheet, columns, rows):
+        self.rect = pygame.Rect(0, 0, sheet.get_width() // columns, sheet.get_height() // rows)
+        for j in range(rows):
+            for i in range(columns):
+                frame_location = (self.rect.w * i, self.rect.h * j)
+                self.frames.append(sheet.subsurface(pygame.Rect(frame_location, self.rect.size)))
+
+    def update(self):
+        self.cur_frame = (self.cur_frame + 1) % len(self.frames)
+        self.image = self.frames[self.cur_frame]
+
+
+dragon = AnimatedSprite(load_image("dragon_sheet8x2.png"), 8, 2, 50, 50)
+
+running = True
+
+while running:
+    for event in pygame.event.get():
+        if event.type == pygame.QUIT:
+            running = False
+    screen.fill(pygame.Color("black"))
+    all_sprites.draw(screen)
+    all_sprites.update()
+    pygame.display.flip()
+
+    clock.tick(FPS)
+
+pygame.quit()
\ No newline at end of file
Index: a.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/a.py b/a.py
new file mode 100644
--- /dev/null	(date 1703251802533)
+++ b/a.py	(date 1703251802533)
@@ -0,0 +1,2 @@
+path = r"Main Characters\a"
+print(path)
\ No newline at end of file
Index: copyfrom/particles.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/copyfrom/particles.py b/copyfrom/particles.py
new file mode 100644
--- /dev/null	(date 1703154505461)
+++ b/copyfrom/particles.py	(date 1703154505461)
@@ -0,0 +1,101 @@
+import os
+import random
+
+import pygame
+
+pygame.init()
+fps = 50
+gravity = 0.25
+
+clock = pygame.time.Clock()
+screen = pygame.display.set_mode((400, 300))
+
+
+def load_image(name, color_key=None):
+    fullname = os.path.join('data', name)
+    try:
+        image = pygame.image.load(fullname).convert()
+    except pygame.error as message:
+        print('Cannot load image:', name)
+        raise SystemExit(message)
+
+    if color_key is not None:
+        if color_key == -1:
+            color_key = image.get_at((0, 0))
+        image.set_colorkey(color_key)
+    else:
+        image = image.convert_alpha()
+    return image
+
+
+
+WIDTH = 400
+HEIGHT = 300
+
+screen = pygame.display.set_mode((WIDTH, HEIGHT))
+
+# для отслеживания улетевших частиц
+# удобно использовать пересечение прямоугольников
+screen_rect = (0, 0, WIDTH, HEIGHT)
+
+
+class Particle(pygame.sprite.Sprite):
+    # сгенерируем частицы разного размера
+    fire = [load_image("star.png")]
+    for scale in (5, 10, 20):
+        fire.append(pygame.transform.scale(fire[0], (scale, scale)))
+
+    def __init__(self, pos, dx, dy):
+        super().__init__(all_sprites)
+        self.image = random.choice(self.fire)
+        self.rect = self.image.get_rect()
+
+        # у каждой частицы своя скорость - это вектор
+        self.velocity = [dx, dy]
+        # и свои координаты
+        self.rect.x, self.rect.y = pos
+
+        # гравитация будет одинаковой
+        self.gravity = gravity
+
+    def update(self):
+        # применяем гравитационный эффект:
+        # движение с ускорением под действием гравитации
+        self.velocity[1] += self.gravity
+        # перемещаем частицу
+        self.rect.x += self.velocity[0]
+        self.rect.y += self.velocity[1]
+        # убиваем, если частица ушла за экран
+        if not self.rect.colliderect(screen_rect):
+            self.kill()
+
+
+def create_particles(position):
+    # количество создаваемых частиц
+    particle_count = 20
+    # возможные скорости
+    numbers = range(-5, 6)
+    for _ in range(particle_count):
+        Particle(position, random.choice(numbers), random.choice(numbers))
+
+
+all_sprites = pygame.sprite.Group()
+pygame.mouse.set_visible(0)
+
+running = True
+
+while running:
+    for event in pygame.event.get():
+        if event.type == pygame.QUIT or (event.type == pygame.KEYUP and event.key == pygame.K_ESCAPE):
+            running = False
+        if event.type == pygame.MOUSEBUTTONDOWN:
+            # создаем частицы по щелчку мыши
+            create_particles(pygame.mouse.get_pos())
+
+    screen.fill((0, 0, 0))
+    all_sprites.draw(screen)
+    all_sprites.update()
+    pygame.display.flip()
+    clock.tick(fps)
+
+pygame.quit()
\ No newline at end of file
